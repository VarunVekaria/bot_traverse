import pygame
import random
import heapq
import numpy as np
from collections import deque
from constants import CELL_SIZE, GRID_MARGIN, BLACK, WHITE, RED, BLUE, GREEN
from neighbors import get_neighbors


# Manhattan distance function
def manhattan_distance(cell1, cell2):
    return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1])

# Find the closest Manhattan distance from a path to any fire cell
def closest_distance_to_fire(path, fire_cells):
    return min(manhattan_distance(cell, fire) for cell in path for fire in fire_cells)

# Function to select the best path based on Manhattan distance to fire
def select_best_path(multiple_paths, fire_cells):
    best_path = None
    max_min_distance = -1

    for path in multiple_paths:
        min_distance_to_fire = closest_distance_to_fire(path, fire_cells)
        if min_distance_to_fire > max_min_distance:
            max_min_distance = min_distance_to_fire
            best_path = path

    return best_path

# Dijkstra's algorithm to find multiple paths
def dijkstra_multiple_paths(matrix, bot_location, button_location, fire_cells, avoid_adjacent_fire=True):
    queue = []
    heapq.heappush(queue, (0, bot_location, [bot_location]))  # (distance, current_position, path)
    visited = {bot_location: 0}  # To track visited nodes and their shortest distance
    multiple_paths = []  # To store all paths

    while queue:
        current_dist, current_pos, path = heapq.heappop(queue)

        # Explore neighbors
        for neighbor in get_neighbors(matrix, current_pos[0], current_pos[1]):
            if matrix[neighbor[0]][neighbor[1]] == 0:
                # Avoid fire cells and adjacent fire cells if possible
                if avoid_adjacent_fire:
                    fire_adjacent = any(n in fire_cells for n in get_neighbors(matrix, neighbor[0], neighbor[1]))
                    if neighbor in fire_cells or fire_adjacent:
                        continue

                new_dist = current_dist + 1  # All edges have the same weight, so add 1
                
                # If the neighbor is the button location, store the path
                if neighbor == button_location:
                    multiple_paths.append(path + [neighbor])
                    # Continue to search for more paths

                # Continue exploring the neighbor
                if neighbor not in visited or new_dist < visited[neighbor]:
                    visited[neighbor] = new_dist
                    heapq.heappush(queue, (new_dist, neighbor, path + [neighbor]))

    print(f'Found {len(multiple_paths)} paths to the button.')
    return multiple_paths

# Move the bot by selecting one of the multiple paths generated by Dijkstra's algorithm
def move_bot_dijkstra_multiple(matrix, bot_location, button_location, fire_cells):
    # Try to avoid fire cells and adjacent fire cells first
    multiple_paths = dijkstra_multiple_paths(matrix, bot_location, button_location, fire_cells, avoid_adjacent_fire=True)

    if not multiple_paths:
        # If no safe path avoiding adjacent fire cells, avoid only fire cells
        multiple_paths = dijkstra_multiple_paths(matrix, bot_location, button_location, fire_cells, avoid_adjacent_fire=False)

    if not multiple_paths:
        print(f"No valid path at step, bot remains at {bot_location}")
        return bot_location, False, []  # No valid path, bot stays in place
    
    print(f"Multiple paths found: {multiple_paths}")  # Log the found paths

    # Select the best path based on distance to fire cells
    best_path = select_best_path(multiple_paths, fire_cells)
    print()
    print("BEST PATH")
    print(best_path)
    print("BEST PATH")
    print()

    return best_path[1], best_path[1] == button_location, best_path  # Move to the next step in the best path

