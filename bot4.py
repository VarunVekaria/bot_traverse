import pygame
import random
import heapq
import numpy as np
from collections import deque
from constants import CELL_SIZE, GRID_MARGIN, BLACK, WHITE, RED, BLUE, GREEN
from neighbors import get_neighbor_cells


# Manhattan distance function
def manhattan_distance(cell1, cell2):
    return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1])

# Find the closest Manhattan distance from a path to any fire cell
def closest_distance_to_fire(path, fire_cells):
    return min(manhattan_distance(cell, fire) for cell in path for fire in fire_cells)

# Function to select the best path based on Manhattan distance to fire
def choose_best_path(possible_paths, fire_cells):
    final_path = None
    max_min_distance = -1

    for path in possible_paths:
        min_distance_to_fire = closest_distance_to_fire(path, fire_cells)
        if min_distance_to_fire > max_min_distance:
            max_min_distance = min_distance_to_fire
            final_path = path

    return final_path

# Dijkstra's algorithm to find multiple paths
def dijkstra_multiple_paths(matrix, bot_initial_position, button_position, fire_cells, avoid_adjacent_fire=True):
    queue = []
    heapq.heappush(queue, (0, bot_initial_position, [bot_initial_position]))  # (distance, current_position_position, path)
    visited_cells = {bot_initial_position: 0}  # To track visited_cells nodes and their shortest distance
    possible_paths = []  # To store all paths

    while queue:
        current_position_dist, current_position_pos, path = heapq.heappop(queue)

        # Explore neighbors
        for neighbor in get_neighbor_cells(matrix, current_position_pos[0], current_position_pos[1]):
            if matrix[neighbor[0]][neighbor[1]] == 0:
                # Avoid fire cells and adjacent fire cells if possible
                if avoid_adjacent_fire:
                    fire_adjacent = any(n in fire_cells for n in get_neighbor_cells(matrix, neighbor[0], neighbor[1]))
                    if neighbor in fire_cells or fire_adjacent:
                        continue

                new_dist = current_position_dist + 1  # All edges have the same weight, so add 1
                
                # If the neighbor is the button location, store the path
                if neighbor == button_position:
                    possible_paths.append(path + [neighbor])
                    # Continue to search for more paths

                # Continue exploring the neighbor
                if neighbor not in visited_cells or new_dist < visited_cells[neighbor]:
                    visited_cells[neighbor] = new_dist
                    heapq.heappush(queue, (new_dist, neighbor, path + [neighbor]))

    print(f'Found {len(possible_paths)} paths to the button.')
    return possible_paths

# Move the bot by selecting one of the multiple paths generated by Dijkstra's algorithm
def move_bot_dijkstra_multiple(matrix, bot_initial_position, button_position, fire_cells):
    # Try to avoid fire cells and adjacent fire cells first
    possible_paths = dijkstra_multiple_paths(matrix, bot_initial_position, button_position, fire_cells, avoid_adjacent_fire=True)

    if not possible_paths:
        # If no safe path avoiding adjacent fire cells, avoid only fire cells
        possible_paths = dijkstra_multiple_paths(matrix, bot_initial_position, button_position, fire_cells, avoid_adjacent_fire=False)

    if not possible_paths:
        print(f"No valid path at step, bot remains at {bot_initial_position}")
        return bot_initial_position, False, []  # No valid path, bot stays in place
    
    print(f"Multiple paths found: {possible_paths}")  # Log the found paths

    # Select the best path based on distance to fire cells
    final_path = choose_best_path(possible_paths, fire_cells)
    print()
    print("FINAL PATH")
    print(final_path)
    print("FINAL PATH")
    print()

    return final_path[1], final_path[1] == button_position, final_path  # Move to the next step in the best path

